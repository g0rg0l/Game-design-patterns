# Патерн Command (Команда)

![image](https://user-images.githubusercontent.com/70606894/197392558-9ff0bbd6-c9ae-4cd7-93a2-ac711f001456.png)

## Предпосылки к использованию

Допустим, вы работаете над созданием какой-то игры, где вам нужно считывать управление пользователя.
Или же вы ведёте разработку приложения с графическим интерфейсом, с которым будет взаимодействовать человек.
Или же вы реализуете механизм, отвечающий структуре  "***Событие -> Действие***".

Казалось бы, нет ничего страшного, будем иметь что-то в роде:

```c++
void pollEvent(Event event)
{
  if (event.type == SOME_TYPE)
  {
    SOME_OBJECT->do_smth();
  }
  ...
}
```

Однако, во-первых, данный стиль оформления кода ведёт к сильной связанности между проверками событий и их выполнением. Таким образом, 
при изменении самого действия `SOME_OBJECT::do_smth()` придётся "залезать под капот" обработчика событий, что не есть хорошо.  
А, во-вторых, предположим, что действие, которое должно выполняться при триггере `event`'a, состоит не из одного шага, как в приведённом выше примере,
а из сотни. Тогда уже и страшно представить, что будет, если таких событий будет хотя бы 10...

Как пример решения подобной проблемы, можно рассмотреть ***отделение*** обработчика событий от выполнения действий, соответствующих этим события.
Паттерн *Command* этим и занимается.

## Описание паттерна

Суть работы паттерна заключается в ***материализации*** какого-то действия, при триггере соответствующего `action`'a.  
Это означет, что вся работа будет происходить где-то в другом месте, куда будет перенаправлен новосозданный материализованный вызов.  
Это решает сразу много проблем (вообще, на самом деле их не только две):
  - Уменьшается связанность обработки событий и выполнения действий, отвечающих соответствующим событиям.
  - Обработчик событий не нагружен "неинтересными" для него вещами.

Материализованный вызов каких-то действий будем называть **Командами (Command)**. Каждая команда будет уметь *запускаться*, тем самым выполняя те самые
действия, которые были в неё заложены при создании. Запуск команд может происходить как непосредственно при её создании, так и неким
**Invoker**'ом (Вызывателем), который будет создавать команды по запросу и запускать их.

## Описание реализации

В моём случае, реализация была следующей:  

Есть игрок, который может перемещаться в 2d пространстве, посредством нажатия на клавиши перемещения.

```c++
class Player : public sf::Drawable
{
...

public:
    void move(float dt);
...
};
```

Есть абстрактый класс `Command`, наследники которого будут являться конкретными Командами.
Команды будут хранить объекты в полях, с которыми им нужно будет работать в `execute()`.

```c++
class Command
{
public:
    Command() = default;
    virtual ~Command() = default;

public:
    virtual void execute() = 0;

};
```

Есть класс `CommandInvoker`, который будет принимать созданные команды и запускать их метод `execute()`  
(Так как в моей реализации команды будут создаваться в динамической памяти, то Invoker заботится ещё и об очистке памяти, после выполнения команды,
которую та занимала).

```c++
class CommandInvoker
{
public:
    CommandInvoker() = default;
    ~CommandInvoker() = default;

public:
     void sendCommand(Command* command)
     {
         command->execute();
         delete command;
     }
};
```

В цикле обработки событий будет считываться управление игрокм, создаваться соответсвующие Команды и отдаваться Invoker'у на обработку.

```c++
...
if (event.type == PLAYER_MOVE_TYPE)
{
    commandInvoker.sendCommand(new MovePlayerCommand(&player, dt));
}
...
```

```c++
class MovePlayerCommand : public Command
{
public:
    MovePlayerCommand(Player* player, float dt);
    ~MovePlayerCommand() override = default;

public:
    void execute() override
    {
        player->move(dt);
    }

private:
    Player* player;
    float dt;
};
```

Вдобавок к этому, сделаем простенькую команду, которая будет выводить в консоль какое-либо сообщение (к примеру, уведомление о запуске игры и её отключении).

```c++
class SendMessageCommand : public Command
{
public:
    explicit SendMessageCommand(std::string message);
    ~SendMessageCommand() override = default;

public:
    void execute() override
    {
        std::cout << message << std::endl;
    }

private:
    const std::string message;
};
```

```c++
...
if (engine.isStopped())
{
  commandInvoker.sendCommand(new SendMessageCommand("game is closing."));
}
...
```

Результат реализации паттерна Command выложен в дополнение к этому тексту - @g0rg0l.
